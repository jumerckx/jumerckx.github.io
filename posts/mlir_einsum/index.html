<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Compiling Einsum to MLIR</title>
		<meta name="description" content="A high-level overview of how einsum expressions in Julia can be compiled to the affine dialect in MLIR.">

		<link rel="icon" href="/icons/favicon.ico" sizes="32x32">
		<link rel="icon" href="/icons/icon.svg" type="image/svg+xml">
		<link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
		<link rel="manifest" href="/icons/site.webmanifest">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="My personal website">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="My personal website">
		
		
		
		<style>/*
 * New diff- syntax
 */

 pre[class*="language-diff-"] {
	--eleventy-code-padding: 1.25em;
	padding-left: var(--eleventy-code-padding);
	padding-right: var(--eleventy-code-padding);
}
.token.deleted {
	background-color: hsl(0, 51%, 37%);
	color: inherit;
}
.token.inserted {
	background-color: hsl(126, 31%, 39%);
	color: inherit;
}

/* Make the + and - characters unselectable for copy/paste */
.token.prefix.unchanged,
.token.prefix.inserted,
.token.prefix.deleted {
	-webkit-user-select: none;
	user-select: none;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	padding-top: 2px;
	padding-bottom: 2px;
}
.token.prefix.inserted,
.token.prefix.deleted {
	width: var(--eleventy-code-padding);
	background-color: rgba(0,0,0,.2);
}

/* Optional: full-width background color */
.token.inserted:not(.prefix),
.token.deleted:not(.prefix) {
	display: block;
	margin-left: calc(-1 * var(--eleventy-code-padding));
	margin-right: calc(-1 * var(--eleventy-code-padding));
	text-decoration: none; /* override del, ins, mark defaults */
	color: inherit; /* override del, ins, mark defaults */
}
article {
    counter-reset: sidenote-counter;
}

input.margin-toggle {
    display: none;
}

label.sidenote-number {
    display: inline-block;
    max-height: 2rem; /* should be less than or equal to paragraph line-height */
}

label.margin-toggle:not(.sidenote-number) {
    display: none;
}

.sidenote,
.marginnote {
    float: right;
    clear: right;
    margin-right: -60%;
    width: 50%;
    margin-top: 0.3rem;
    margin-bottom: 0;
    font-size: 1.1rem;
    line-height: 1.3;
    vertical-align: baseline;
    position: relative;
    margin-bottom: 1em;
}

.sidenote-number {
    counter-increment: sidenote-counter;
}

.sidenote-number:after,
.sidenote:before {
    font-family: et-book-roman-old-style;
    position: relative;
    vertical-align: baseline;
}

.sidenote-number:after {
    content: counter(sidenote-counter);
    font-size: 1rem;
    top: -0.5rem;
    left: 0.1rem;
}

.sidenote:before {
    content: counter(sidenote-counter) " ";
    font-size: 1rem;
    top: -0.5rem;
}

blockquote .sidenote,
blockquote .marginnote {
    margin-right: -82%;
    min-width: 59%;
    text-align: left;
}

@media (max-width: 760px) {
    label.margin-toggle:not(.sidenote-number) {
        display: inline;
    }

    .sidenote,
    .marginnote {
        display: none;
        margin-bottom: 0;
    }

    .margin-toggle:checked + .sidenote,
    .margin-toggle:checked + .marginnote {
        display: block;
        float: left;
        left: 1rem;
        clear: both;
        width: 95%;
        margin: 1rem 2.5%;
        position: relative;
    }
    label {
        cursor: pointer;
    }
}
.header-anchor {
    text-decoration: none;
}

:root {
    --sans: "Soehne", system-ui, -apple-system, Helvetica Neue, Arial, sans-serif;
    --circle: "Soehne Circle", sans-serif;
    --serif: "Signifier", ui-serif, Georgia, Cambria, Times New Roman, Times, serif;
    --mono: "Inconsolata", "Monaco", "Consolas", 'Courier New', Courier, monospace;
}

* {
    box-sizing: border-box;
}

a {
    color: inherit;
    font-style: italic;
    text-decoration-style: dashed;
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

header {
	border-bottom: 1px dashed var(--color-gray-20);
}
header:after {
	content: "";
	display: table;
	clear: both;
}
/* Header */
header {
	display: flex;
	gap: 1em .5em;
	flex-wrap: wrap;
	align-items: center;
	padding: 1em 0 1em 0;
}
.home-link {
	font-size: 1em; /* 16px /16 */
	font-weight: 700;
	margin-right: 2em;
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */

.nav {
    font-family: var(--sans);
    font-size: x-large;
    font-weight: bold;
	display: flex;
	padding: 0;
	margin: 0;
	list-style: none;
}
.nav-item {
	display: inline-block;
	margin-right: 1em;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}


body {
    background-color: #f7f3eb;
    font-size: 1.3125rem;
    margin: 0 0 100px 0;
    width: 100%;
    max-width: calc(12.5% + 1400px);
    padding-left: 10.5%;
    font-family: var(--serif);
}

article {
    width: 55%;
    position: relative;
    padding: 0rem 0;
}

article>p {
    line-height: 140%;
}

article>figure>img,
article>img {
    display:block;
    margin-left: auto;
    margin-right: auto;
    max-width: 100%;
}
article>figure>figcaption {
    font-size: 0.8em;
    text-align: center;
    font-style: italic;
    margin-top: 0.5em;
}

@media screen and (max-width: 1079px) {
    .hstack {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
    }
    .hstack-item {
        max-width: 100%;
        justify-content: center;
    }
}

@media screen and (max-width: 760px) {
    article {
        width: 90%;
    }
    
}

article>h1 {
    font-family: var(--sans);
    font-size: 50px;
    /* line-height: 150%; */
}

.footnote-ref>a{
    font-size: 0.8em;
    vertical-align: super;
    line-height: 0;
}

img {
    max-width:100%
}

code {
    border-radius: 3px;
    background: #f4ece0;
    padding: 2px;
    color: #444444;
    position: relative;
    bottom: 1px;
    font-family: var(--mono);
}

code[class*="language-"],
pre[class*="language-"] {
    font-size: 1rem !important;
}
/*
 * Based on Plugin: Syntax Highlighter CB
 * Plugin URI: http://wp.tutsplus.com/tutorials/plugins/adding-a-syntax-highlighter-shortcode-using-prism-js
 * Description: Highlight your code snippets with an easy to use shortcode based on Lea Verou's Prism.js.
 * Version: 1.0.0
 * Author: c.bavota
 * Author URI: http://bavotasan.comhttp://wp.tutsplus.com/tutorials/plugins/adding-a-syntax-highlighter-shortcode-using-prism-js/ */
/* http://cbavota.bitbucket.org/syntax-highlighter/  */

/* =====   ===== */
code[class*="language-"],
pre[class*="language-"] {
	text-shadow: 0 1px 1px #000;
	color: #fff;
	background: none;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;

	font-family: Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;
}

pre[class*="language-"] code {
	float: left;
	padding: 0 15px 0 0;
}

pre[class*="language-"],
:not(pre) > code[class*="language-"] {
	background: #222;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 15px;
	margin: 1em 0;
	overflow: auto;
	-moz-border-radius: 8px;
	-webkit-border-radius: 8px;
	border-radius: 8px;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: 5px 10px;
	line-height: 1;
	-moz-border-radius: 3px;
	-webkit-border-radius: 3px;
	border-radius: 3px;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #797979;
}

.token.selector,
.token.operator,
.token.punctuation {
	color: #fff7ed;
}

.token.namespace {
	opacity: .7;
}

.token.tag,
.token.boolean {
	color: #ffd893;
}

.token.atrule,
.token.attr-value,
.token.hex,
.token.string {
	color: #B0C975;
}

.token.property,
.token.entity,
.token.url,
.token.attr-name,
.token.keyword {
	color: #c27628;
}

.token.regex {
	color: #9B71C6;
}

.token.entity {
	cursor: help;
}

.token.function,
.token.constant {
	color: #e5a638;
}

.token.variable {
	color: #f5e5c2;
}

.token.number {
	color: #8799B0;
}

.token.important,
.token.deliminator {
	color: #E45734;
}

/* Line highlight plugin */
.line-highlight.line-highlight {
	background: rgba(255, 255, 255, .2);
}

.line-highlight.line-highlight:before,
.line-highlight.line-highlight[data-end]:after {
	top: .3em;
	background-color: rgba(255, 255, 255, .3);
	color: #fff;
	-moz-border-radius: 8px;
	-webkit-border-radius: 8px;
	border-radius: 8px;
}

/* for line numbers */
/* span instead of span:before for a two-toned border */
.line-numbers .line-numbers-rows > span {
	border-right: 3px #d9d336 solid;
}</style>
	</head>
	<body>
		<header>
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
				</ul>
			</nav>
		</header>
		


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">




<article>
    <h1 style="margin-bottom:0">Compiling Einsum to MLIR</h1>
    <p style="margin: 0; font-style: italic; font-size:smaller">January 03, 2024</p>
    <hr style="border: 2px solid #c0b6a7">
    <h4>On This Page</h4>
    <aside>
    <nav class="toc" >
        <ul><li><a href="#the-idea">The Idea</a></li><li><a href="#julia-and-mlir">Julia and MLIR</a><ul><li><a href="#julia">Julia</a></li><li><a href="#mlir">MLIR</a></li></ul></li><li><a href="#the-julia-compilation-pipeline">The Julia Compilation Pipeline</a></li><li><a href="#where-did-my-loops-go%3F">Where Did My Loops Go?</a></li><li><a href="#generating-mlir">Generating MLIR</a></li><li><a href="#where-to-go-from-here">Where to Go From Here</a></li></ul>
      </nav>
    </aside>
    <hr style="border: 2px solid #c0b6a7">
    <p>The <em>Einstein summation</em> convention, <em>einsum</em> convention in short, is a notational convention for specifying operations on multidimensional arrays.<br>
It has uses in many branches of scientific computing ranging from tensor networks used in physics to expressing new, exotic deep learning operators.<br>
Below, two examples are shown. Each element of the array in the left-hand side of the expression is given by the result of computing the value for all possible indices on the right-hand side and summing over all indices that don't appear in the result.<label for="sn-notation" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-notation" class="margin-toggle"/><span class="sidenote">The notation used here doesn't match with e.g. Numpy or Pytorch's way of representing einsums. In these packages, these examples would be<br><code>einsum('i,i-&gt;i', [A, B])</code> and<br><code>einsum('ik,kj-&gt;ij', [α*A, α*B])</code>.<br>Though equivalent, I find the notation used in this post slightly easier to parse.</span></p>
<pre class="language-julia"><code class="language-julia"><span class="token comment"># elementwise addition</span>
C<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

<span class="token comment"># matrix multiplication</span>
C<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> α <span class="token operator">*</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>k<span class="token punctuation">,</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<p>This post isn't concerned with how to write einsum notation to implement linear algebra operations<label for="sn-einsum-explanation" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-einsum-explanation" class="margin-toggle"/><span class="sidenote">For an overview of einsum from a deep learning perspective, you might want to read <a href="https://rockt.github.io/2018/04/30/einsum">this</a> write-up by Tim Rocktäschel.</span>, rather, it goes over how these expressions can actually be compiled and run on your computer.</p>
<h2 id="the-idea" tabindex="-1"><a class="header-anchor" href="#the-idea">The Idea</a></h2>
<p>The basic principle of generating code for an einsum expression is to create a series of nested loops. The outer loops loop over each element in the output array (left-hand side). While the inner loops loop over any indices that only appear in the inputs (right-hand side). For these inner loops, the result is aggregated.</p>
<p>For example, with arrays <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> being of size (N×K), (K×M) and (N×M) respectively, you get:</p>
<pre class="language-julia"><code class="language-julia"><span class="token comment"># (matrix multiplication)</span>
<span class="token comment">#   C[i, j] = A[i, k]*B[k, j]</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">:</span>N
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">:</span>M
        temp <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">:</span>K
            temp <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>k<span class="token punctuation">,</span> j<span class="token punctuation">]</span>
        <span class="token keyword">end</span>
        C<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> temp
    <span class="token keyword">end</span>
<span class="token keyword">end</span></code></pre>
<p>This is of course a contrived example as we could simply call into BLAS (<code>C = A*B</code>) and get code that is much faster because it has been optimized to death.<label for="sn-opt_einsum" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-opt_einsum" class="margin-toggle"/><span class="sidenote">Note also that this is the most naive approach to generating code for einsum expressions. Different implementations might gain a lot of additional performance by reordering loops and trying to map them on BLAS operations automatically. e.g. <a href="https://optimized-einsum.readthedocs.io/en/stable/">opt_einsum</a> (in Python), and <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a> (in Julia)</span></p>
<p>However, in combination with an optimizing compiler, the simple approach outlined above has proven to be competitive for some cases that don't simply map on one or two BLAS calls.</p>
<h2 id="julia-and-mlir" tabindex="-1"><a class="header-anchor" href="#julia-and-mlir">Julia and MLIR</a></h2>
<h3 id="julia" tabindex="-1"><a class="header-anchor" href="#julia">Julia</a></h3>
<p>The Julia programming language uses the LLVM compiler and because of its powerful metaprogramming capabilities, it's the ideal breeding ground<label for="sn-many-julia-packages" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-many-julia-packages" class="margin-toggle"/><span class="sidenote"><a href="https://github.com/ahwillia/Einsum.jl">Einsum.jl</a>, <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a>, <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>, <a href="https://github.com/mcabbott/Tullio.jl">Tullio.jl</a>, <a href="https://github.com/mcabbott/TensorCast.jl">TensorCast.jl</a>, <a href="https://github.com/ho-oto/TensorRules.jl">TensorRules.jl</a>, …</span> for einsum packages and similar domain specific languages for tensor operations.<br>
These different packages typically expose <em>macros</em> to convert an einsum expression (or something similar) to valid Julia code. This code is then compiled just as if it were manually written by the user and out comes the optimized machine code.</p>
<h3 id="mlir" tabindex="-1"><a class="header-anchor" href="#mlir">MLIR</a></h3>
<p>Now, what's MLIR and where does it come into the picture?<br>
MLIR (Multi-Level Intermediate Representation) is a compiler infrastructure project providing tools to create <em>intermediate representations</em> (IRs) and passes to transform them.<br>
If you're familiar with LLVM, this might sound familiar, and you'd be right. In fact, MLIR is part of the LLVM project but its IR is more flexible and modular than LLVM IR.<br>
For example, in MLIR it's possible to represent high-level deep learning operations (e.g. matmul, convolution, …), low-level machine intrinsics (e.g. AVX512 instructions), and everything in between, all in the same IR. This is done by defining different <em>dialects</em>, each having their own set of operations and types.<br>
MLIR also has the <code>affine</code> dialect, which is used to represent polyhedral structures. This is a very powerful dialect that can be used to represent loops and their dependencies in a way that allows for powerful transformations and optimizations.</p>
<p>What if we generate affine MLIR IR from the einsum expression? This would allow us to use the MLIR infrastructure to optimize the code and generate machine code for different targets (e.g. CPU, GPU, …). Turns out, we can.</p>
<h2 id="the-julia-compilation-pipeline" tabindex="-1"><a class="header-anchor" href="#the-julia-compilation-pipeline">The Julia Compilation Pipeline</a></h2>
<p>Julia code typically goes through a few different steps before becoming the machine code that's actually executed on your machine.<br>
First is parsing, where code is converted to an abstract syntax tree without any semantic information. In Julia, macros can be used to alter code after parsing, taking in expressions and returning expressions. Next is lowering, where the AST is converted to Julia IR, a format that can contain type information and some optimizations such as inlining, constant propagation, … At this level, it's also possible to apply transformations using the same functions the Julia compiler uses internally.<label for="sn-julia-compiler" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-julia-compiler" class="margin-toggle"/><span class="sidenote">Large parts of the Julia compiler itself are written in Julia.</span> Finally we have codegen. Here, the Julia IR is converted to LLVM IR, which is then further compiled to machine code and executed.</p>
<figure>
<img alt="Overview of the Julia compilation pipeline, figure adapted from Besard et.al." loading="lazy" decoding="async" src="/img/LHhMazEux9-232.svg" width="232" height="355">
<figcaption>
This figure is taken from <a href="http://dx.doi.org/10.1109/TPDS.2018.2872064">Effective extensible programming: unleashing Julia on GPUs (Besard, 2018)</a>
</figcaption>
</figure>
In an effort to reuse some of Julia's compiler infrastructure (most notably type inference), we'll try emitting MLIR from Julia IR instead of starting from the AST.
There's only one problem.
<h2 id="where-did-my-loops-go%3F" tabindex="-1"><a class="header-anchor" href="#where-did-my-loops-go%3F">Where Did My Loops Go?</a></h2>
<p>Take one of the simplest einsum expressions, an elementwise copy from vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> to vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>:</p>
<pre class="language-julia"><code class="language-julia">@einsum y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span></code></pre>
<p>The <code>@einsum</code> macro will expand this to the following code:</p>
<pre class="language-julia"><code class="language-julia"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">:</span>length<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">end</span></code></pre>
<p>And lowering to Julia IRCode, we get:<label for="sn-julia_ir" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-julia_ir" class="margin-toggle"/><span class="sidenote">With <code>Julia 1.11</code> and beyond, this IR looks quite different because the <code>Array</code> type was <a href="https://github.com/JuliaLang/julia/pull/51319">redesigned</a>. I show here the output from <code>Julia 1.9</code> as it is slightly shorter and easier to follow.</span></p>
<pre class="language-llvm"><code class="language-llvm"><span class="token number">1</span> ── <span class="token variable">%1</span>  <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">arraylen</span><span class="token punctuation">(</span><span class="token keyword">_2</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%2</span>  <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">sle_int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">%1</span><span class="token punctuation">)</span>::Bool
└───       <span class="token keyword">goto</span> <span class="token variable">#3</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token variable">%2</span>
<span class="token number">2</span> ──       <span class="token keyword">goto</span> <span class="token variable">#4</span>
<span class="token number">3</span> ──       <span class="token keyword">goto</span> <span class="token variable">#4</span>
<span class="token number">4</span> ┄─ <span class="token variable">%6</span>  <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#2</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%1</span><span class="token punctuation">,</span> <span class="token variable">#3</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token number">0</span><span class="token punctuation">)</span>::Int64
└───       <span class="token keyword">goto</span> <span class="token variable">#5</span>
<span class="token number">5</span> ──       <span class="token keyword">goto</span> <span class="token variable">#6</span>
<span class="token number">6</span> ── <span class="token variable">%9</span>  <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">slt_int</span><span class="token punctuation">(</span><span class="token variable">%6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>::Bool
└───       <span class="token keyword">goto</span> <span class="token variable">#8</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token variable">%9</span>
<span class="token number">7</span> ──       <span class="token keyword">goto</span> <span class="token variable">#9</span>
<span class="token number">8</span> ──       <span class="token keyword">goto</span> <span class="token variable">#9</span>
<span class="token number">9</span> ┄─ <span class="token variable">%13</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#7</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token variable">#8</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token boolean">false</span><span class="token punctuation">)</span>::Bool
│    <span class="token variable">%14</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#8</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token number">1</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%15</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#8</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token number">1</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%16</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">not_int</span><span class="token punctuation">(</span><span class="token variable">%13</span><span class="token punctuation">)</span>::Bool
└───       <span class="token keyword">goto</span> <span class="token variable">#15</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token variable">%16</span>
<span class="token number">10</span> ┄ <span class="token variable">%18</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#9</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%14</span><span class="token punctuation">,</span> <span class="token variable">#14</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%27</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%19</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#9</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%15</span><span class="token punctuation">,</span> <span class="token variable">#14</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%28</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%20</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">arrayref</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">_2</span><span class="token punctuation">,</span> <span class="token variable">%18</span><span class="token punctuation">)</span>::Float64
│          Base<span class="token punctuation">.</span><span class="token keyword">arrayset</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">_3</span><span class="token punctuation">,</span> <span class="token variable">%20</span><span class="token punctuation">,</span> <span class="token variable">%18</span><span class="token punctuation">)</span>::Vector<span class="token punctuation">{</span>Float64<span class="token punctuation">}</span>
│    <span class="token variable">%22</span> <span class="token punctuation">=</span> <span class="token punctuation">(</span><span class="token variable">%19</span> <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token variable">%6</span><span class="token punctuation">)</span>::Bool
└───       <span class="token keyword">goto</span> <span class="token variable">#12</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token variable">%22</span>
<span class="token number">11</span> ─       <span class="token keyword">goto</span> <span class="token variable">#13</span>
<span class="token number">12</span> ─ <span class="token variable">%25</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">add_int</span><span class="token punctuation">(</span><span class="token variable">%19</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>::Int64
└───       <span class="token keyword">goto</span> <span class="token variable">#13</span>
<span class="token number">13</span> ┄ <span class="token variable">%27</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#12</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%25</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%28</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#12</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token variable">%25</span><span class="token punctuation">)</span>::Int64
│    <span class="token variable">%29</span> <span class="token punctuation">=</span> φ <span class="token punctuation">(</span><span class="token variable">#11</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token variable">#12</span> <span class="token punctuation">=</span><span class="token punctuation">></span> <span class="token boolean">false</span><span class="token punctuation">)</span>::Bool
│    <span class="token variable">%30</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">not_int</span><span class="token punctuation">(</span><span class="token variable">%29</span><span class="token punctuation">)</span>::Bool
└───       <span class="token keyword">goto</span> <span class="token variable">#15</span> <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token variable">%30</span>
<span class="token number">14</span> ─       <span class="token keyword">goto</span> <span class="token variable">#10</span>
<span class="token number">15</span> ┄       <span class="token keyword">return</span> <span class="token keyword">nothing</span>
<span class="token punctuation">=</span><span class="token punctuation">></span> Nothing</code></pre>
<p>Looking at the Julia IR, it might be difficult to spot the for loops in the original function. That's because Julia IR only contains <em>unstructured control flow</em>, these are (conditional) goto statements.<label for="sn-phi-nodes" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-phi-nodes" class="margin-toggle"/><span class="sidenote">Aditionally, the phi-nodes (<code>φ</code>) in the IR can be seen as operations returning a different value depending on from which block the execution flow is coming.<br>So <code>φ (#2 =&gt; %1, #3 =&gt; 0)</code> should be read as “if the execution flow is coming from block 2, return value <code>%1</code>, otherwise return the constant <code>0</code>”.</span> For generating MLIR, that's a problem. Even though MLIR has a dialect for unstructured control flow<label for="sn-cf" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-cf" class="margin-toggle"/><span class="sidenote"><a href="https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/">The <em>cf</em> dialect</a></span>, our goal is to keep the IR as structured as possible. This way, it's easier to apply transformations and optimizations.</p>
<p>To still have a way to easily recover a for loop from Julia IR, we can replace the for loop by two carefully crafted function calls <code>begin_for</code> and <code>yield_for</code>.</p>
<pre class="language-julia"><code class="language-julia"><span class="token comment"># instead of writing:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">:</span>length<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">end</span>

<span class="token comment"># write: </span>
i <span class="token operator">=</span> Brutus<span class="token punctuation">.</span>begin_for<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
Brutus<span class="token punctuation">.</span>yield_for<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>The <em>only</em> use for these functions is to show up in Julia IR. Apart from that, they don't do anything. The Julia code does not work anymore, since the functions don't have a sensible definition, but that's not a problem since we're only interested in the IR.</p>
<pre class="language-llvm"><code class="language-llvm"><span class="token number">1</span> ─ <span class="token variable">%1</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">arraylen</span><span class="token punctuation">(</span><span class="token keyword">_2</span><span class="token punctuation">)</span>::Int64
│   <span class="token variable">%2</span> <span class="token punctuation">=</span> <span class="token keyword">invoke</span> Main<span class="token punctuation">.</span><span class="token keyword">begin_for</span><span class="token punctuation">(</span><span class="token number">1</span>::Int64<span class="token punctuation">,</span> <span class="token variable">%1</span>::Int64<span class="token punctuation">)</span>::Int64
│   <span class="token variable">%3</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">arrayref</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">_2</span><span class="token punctuation">,</span> <span class="token variable">%2</span><span class="token punctuation">)</span>::Float64
│        Base<span class="token punctuation">.</span><span class="token keyword">arrayset</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">_3</span><span class="token punctuation">,</span> <span class="token variable">%3</span><span class="token punctuation">,</span> <span class="token variable">%2</span><span class="token punctuation">)</span>::Vector<span class="token punctuation">{</span>Float64<span class="token punctuation">}</span>
│   <span class="token variable">%5</span> <span class="token punctuation">=</span> <span class="token keyword">invoke</span> Main<span class="token punctuation">.</span><span class="token keyword">yield_for</span><span class="token punctuation">(</span><span class="token punctuation">)</span>::Core<span class="token punctuation">.</span>Const<span class="token punctuation">(</span><span class="token keyword">nothing</span><span class="token punctuation">)</span>
└──      <span class="token keyword">return</span> <span class="token variable">%5</span>
<span class="token punctuation">=</span><span class="token punctuation">></span> Nothing</code></pre>
<p>The unstructured control flow has disappeared and we now see our two function calls clearly demarcating the loop body. The reason why the IR is so much shorter is also because some of the bounds checking has disappeared. Let's ignore that for now.</p>
<p>We also need a way to represent an accumulator variable that is updated in the loop body. This can be done by making <code>begin_for</code> have an extra argument (the initial value), and a second output (the accumulator variable). The accumulator variable is then passed to <code>yield_for</code> which will also return it.</p>
<pre class="language-julia"><code class="language-julia">⋮
accumulator<span class="token punctuation">,</span> i <span class="token operator">=</span> Brutus<span class="token punctuation">.</span>begin_for<span class="token punctuation">(</span>initial_value<span class="token punctuation">,</span> start<span class="token punctuation">,</span> stop<span class="token punctuation">)</span>
accumulator <span class="token operator">+=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">,</span> k<span class="token punctuation">]</span> <span class="token operator">*</span> c<span class="token punctuation">[</span>k<span class="token punctuation">,</span> j<span class="token punctuation">]</span>
accumulator <span class="token operator">=</span> Brutus<span class="token punctuation">.</span>yield_for<span class="token punctuation">(</span>accumulator<span class="token punctuation">)</span>
⋮</code></pre>
<p>By hacking the existing Einsum.jl package to emit these functions instead of for loops, we now have a way to generate Julia IR that is ready to be converted to MLIR.</p>
<h2 id="generating-mlir" tabindex="-1"><a class="header-anchor" href="#generating-mlir">Generating MLIR</a></h2>
<p>Interfacing Julia with MLIR is relatively straightforward thanks to the MLIR C API and Julia's abillity to call C functions directly using <code>ccall</code>. The MLIR C API is a minimal wrapper around the MLIR framework, which is written in C++, and allows building IR among other things. In Julia, this C API is wrapped and a higher-level API for IR handling is exposed in the <a href="https://github.com/JuliaLabs/MLIR.jl/blob/main/src/IR/IR.jl">MLIR.jl package</a>.<label for="sn-ir-api" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-ir-api" class="margin-toggle"/><span class="sidenote">To my knowledge, this higher-level API was first developed in the <a href="https://github.com/Pangoraw/Coil.jl">Coil.jl</a> project.</span><br>
The MLIR C API doesn't contain a lot of dialect-specific functionality. The <code>mlirOperationCreate</code> function allows to build operations to insert into IR, but is overly generic and annoyingly verbose to use when generating many operations. To also get a higher-level Julia API for each dialect, we can use <a href="https://github.com/JuliaLabs/MLIR.jl/pull/19">a tool</a> to generate Julia code based on dialect Operation Definition Specifications (ODS).<label for="sn-ods" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-ods" class="margin-toggle"/><span class="sidenote">This is similar to how the official <a href="https://mlir.llvm.org/docs/Bindings/Python/#integration-with-ods">Python API</a> and <a href="https://github.com/google/mlir-hs">mlir-hs</a> (Haskell) integrate more tightly with dialect specifications.</span> These specifications are stored in <em>tablegen</em> files, a special domain-specific language used by the LLVM project that is typically converted to C++ source code.</p>
<p>Generating MLIR comes down to looping over all Julia IR statements and emitting the corresponding MLIR operations. Simple binary operations such as <code>Base.mul_int</code> (integer multiplication) can be mapped directly onto an existing operation in MLIR (e.g. <code>arith.muli</code>).<br>
Unsuprisingly, instructions such as our <code>begin_for</code> and <code>yield_for</code>, need a little more care. A <code>begin_for</code> instruction signals that following instructions need to be nested within the loop body. In practice this means a new MLIR Region is created and used until the corresponding <code>yield_for</code> is encountered.<label for="sn-loop-regions" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-loop-regions" class="margin-toggle"/><span class="sidenote">In fact, since the loop body region can only contain one block, two regions are created. The innermost region contains all the blocks from the Julia IR - typically more than one. The outermost region contains a single block with the operation <code>scf.execute_region</code> which will simply execute that child region (containing multiple blocks). Since we're dealing with simple IR, an MLIR canonicalization pass will typically simplify this by merging multiple blocks and getting rid of the surrounding <code>execute_region</code>.</span> The for loop itself also can't be created immediately because its loop body region is not complete yet. Instead a thunk is put on a stack and will be called once the <code>yield_for</code> is encountered.</p>
<p>We can use the same simple vector copy example. <code>Base.code_ircode</code> can be used to see what Julia IR is generated for a function. The second argument to that function contains the argument types.<label for="sn-memref-type" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-memref-type" class="margin-toggle"/><span class="sidenote"><code>MemRef</code> isn't a builtin Julia type. Rather, it's a custom Array type that dispatches its <code>getindex</code> and <code>setindex</code> methods to <code>mlir_load</code> and <code>mlir_store</code> invocations. These functions are similar to our custom <code>begin_for</code> and <code>yield_for</code> in that the only purpose for them is to show up in the IR, they can't be executed in regular Julia.<br>If you'd use regular array arguments, a lot more Julia IR would be generated including boundschecks and error handling. These could eventually be handled correctly but for now its easier to just get rid of them in this way.</span></p>
<pre class="language-julia"><code class="language-julia">f<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> @einsum y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
Base<span class="token punctuation">.</span>code_ircode<span class="token punctuation">(</span>f<span class="token punctuation">,</span> Tuple<span class="token punctuation">{</span>MemRef<span class="token punctuation">{</span>Float64<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> MemRef<span class="token punctuation">{</span>Float64<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>This returns the following Julia IR:</p>
<pre class="language-llvm"><code class="language-llvm">⋮
<span class="token variable">%13</span> <span class="token punctuation">=</span> <span class="token keyword">invoke</span> Brutus<span class="token punctuation">.</span><span class="token keyword">begin_for</span><span class="token punctuation">(</span><span class="token number">1</span>::Int64<span class="token punctuation">,</span> <span class="token variable">%12</span>::Int64<span class="token punctuation">)</span>::Int64
<span class="token variable">%14</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">sub_int</span><span class="token punctuation">(</span><span class="token variable">%13</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>::Int64
<span class="token variable">%15</span> <span class="token punctuation">=</span> <span class="token keyword">invoke</span> Brutus<span class="token punctuation">.</span><span class="token keyword">mlir_load</span><span class="token punctuation">(</span><span class="token label">_3:</span>:MemRef<span class="token punctuation">{</span>Float64<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token variable">%14</span>::Int64<span class="token punctuation">)</span>::Float64
<span class="token variable">%16</span> <span class="token punctuation">=</span> Base<span class="token punctuation">.</span><span class="token keyword">sub_int</span><span class="token punctuation">(</span><span class="token variable">%13</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>::Int64
<span class="token keyword">invoke</span> Brutus<span class="token punctuation">.</span><span class="token keyword">mlir_store</span><span class="token punctuation">!</span><span class="token punctuation">(</span><span class="token label">_2:</span>:MemRef<span class="token punctuation">{</span>Float64<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token variable">%15</span>::Float64<span class="token punctuation">,</span> <span class="token variable">%16</span>::Int64<span class="token punctuation">)</span>::Float64
<span class="token keyword">invoke</span> Brutus<span class="token punctuation">.</span><span class="token keyword">yield_for</span><span class="token punctuation">(</span><span class="token punctuation">)</span>::Any
⋮</code></pre>
<p><code>code_mlir</code> is the function that will loop over all Julia IR and create the corresponding MLIR:</p>
<pre class="language-julia"><code class="language-julia">code_mlir<span class="token punctuation">(</span>f<span class="token punctuation">,</span> Tuple<span class="token punctuation">{</span>Brutus<span class="token punctuation">.</span>MemRef<span class="token punctuation">{</span>Float64<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Brutus<span class="token punctuation">.</span>MemRef<span class="token punctuation">{</span>Float64<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>which returns:</p>
<pre class="language-llvm"><code class="language-llvm">⋮
<span class="token keyword">scf</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token variable">%arg2</span> <span class="token punctuation">=</span> <span class="token variable">%c1_4</span> <span class="token keyword">to</span> <span class="token variable">%6</span> <span class="token keyword">step</span> <span class="token variable">%c1_6</span> <span class="token punctuation">{</span>
    <span class="token keyword">scf</span><span class="token punctuation">.</span><span class="token keyword">execute_region</span> <span class="token punctuation">{</span>
        <span class="token variable">%8</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%arg2</span> : <span class="token keyword">index</span> <span class="token keyword">to</span> <span class="token type class-name">i64</span>
        <span class="token variable">%c1_8</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">constant</span> <span class="token number">1</span> : <span class="token keyword">index</span>
        <span class="token variable">%9</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%c1_8</span> : <span class="token keyword">index</span> <span class="token keyword">to</span> <span class="token type class-name">i64</span>
        <span class="token variable">%10</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">subi</span> <span class="token variable">%8</span><span class="token punctuation">,</span> <span class="token variable">%9</span> : <span class="token type class-name">i64</span>
        <span class="token variable">%11</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%10</span> : <span class="token type class-name">i64</span> <span class="token keyword">to</span> <span class="token keyword">index</span>
        <span class="token variable">%12</span> <span class="token punctuation">=</span> <span class="token keyword">memref</span><span class="token punctuation">.</span><span class="token keyword">load</span> <span class="token variable">%arg1</span><span class="token punctuation">[</span><span class="token variable">%11</span><span class="token punctuation">]</span> : <span class="token keyword">memref</span><span class="token punctuation">&lt;</span>?<span class="token keyword">xf64</span><span class="token punctuation">,</span> <span class="token keyword">strided</span><span class="token punctuation">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token label">offset:</span> ?<span class="token punctuation">></span><span class="token punctuation">></span>
        <span class="token variable">%13</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%arg2</span> : <span class="token keyword">index</span> <span class="token keyword">to</span> <span class="token type class-name">i64</span>
        <span class="token variable">%c1_9</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">constant</span> <span class="token number">1</span> : <span class="token keyword">index</span>
        <span class="token variable">%14</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%c1_9</span> : <span class="token keyword">index</span> <span class="token keyword">to</span> <span class="token type class-name">i64</span>
        <span class="token variable">%15</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">subi</span> <span class="token variable">%13</span><span class="token punctuation">,</span> <span class="token variable">%14</span> : <span class="token type class-name">i64</span>
        <span class="token variable">%16</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%15</span> : <span class="token type class-name">i64</span> <span class="token keyword">to</span> <span class="token keyword">index</span>
        <span class="token keyword">memref</span><span class="token punctuation">.</span><span class="token keyword">store</span> <span class="token variable">%12</span><span class="token punctuation">,</span> <span class="token variable">%arg0</span><span class="token punctuation">[</span><span class="token variable">%16</span><span class="token punctuation">]</span> : <span class="token keyword">memref</span><span class="token punctuation">&lt;</span>?<span class="token keyword">xf64</span><span class="token punctuation">,</span> <span class="token keyword">strided</span><span class="token punctuation">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token label">offset:</span> ?<span class="token punctuation">></span><span class="token punctuation">></span>
        <span class="token keyword">scf</span><span class="token punctuation">.</span><span class="token keyword">yield</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
⋮</code></pre>
<p>A lot of arithmetic operations are generated to support the one-based, column-major layout of Julia arrays and conversion between index and integer types. After canonicalization in MLIR, most of these operations are processed away and we're left with the following:</p>
<pre class="language-llvm"><code class="language-llvm">⋮
<span class="token keyword">scf</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token variable">%arg2</span> <span class="token punctuation">=</span> <span class="token variable">%c1</span> <span class="token keyword">to</span> <span class="token variable">%4</span> <span class="token keyword">step</span> <span class="token variable">%c1</span> <span class="token punctuation">{</span>
    <span class="token variable">%5</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%arg2</span> : <span class="token keyword">index</span> <span class="token keyword">to</span> <span class="token type class-name">i64</span>
    <span class="token variable">%6</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">subi</span> <span class="token variable">%5</span><span class="token punctuation">,</span> <span class="token variable">%c1_i64</span> : <span class="token type class-name">i64</span>
    <span class="token variable">%7</span> <span class="token punctuation">=</span> <span class="token keyword">arith</span><span class="token punctuation">.</span><span class="token keyword">index_cast</span> <span class="token variable">%6</span> : <span class="token type class-name">i64</span> <span class="token keyword">to</span> <span class="token keyword">index</span>
    <span class="token variable">%8</span> <span class="token punctuation">=</span> <span class="token keyword">memref</span><span class="token punctuation">.</span><span class="token keyword">load</span> <span class="token variable">%arg1</span><span class="token punctuation">[</span><span class="token variable">%7</span><span class="token punctuation">]</span> : <span class="token keyword">memref</span><span class="token punctuation">&lt;</span>?<span class="token keyword">xf64</span><span class="token punctuation">,</span> <span class="token keyword">strided</span><span class="token punctuation">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token label">offset:</span> ?<span class="token punctuation">></span><span class="token punctuation">></span>
    <span class="token keyword">memref</span><span class="token punctuation">.</span><span class="token keyword">store</span> <span class="token variable">%8</span><span class="token punctuation">,</span> <span class="token variable">%arg0</span><span class="token punctuation">[</span><span class="token variable">%7</span><span class="token punctuation">]</span> : <span class="token keyword">memref</span><span class="token punctuation">&lt;</span>?<span class="token keyword">xf64</span><span class="token punctuation">,</span> <span class="token keyword">strided</span><span class="token punctuation">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token label">offset:</span> ?<span class="token punctuation">></span><span class="token punctuation">></span>
<span class="token punctuation">}</span>
⋮</code></pre>
<p>Some details are not discussed here. For example the Julia IR generally contains control flow operations (<code>br</code>, <code>return</code>, <code>φ</code>-nodes, …) that need to be handled. This, and a lot of the plumbing required to make this work was developed by Pangoraw in this <a href="https://github.com/JuliaLabs/MLIR.jl/pull/11/files#diff-aba42df185bcd1b68b91046027f58478e2e1ae31e3ab106a076bdea141342165">pull request</a>. Pangoraw also wrote <a href="https://github.com/Pangoraw/Coil.jl">Coil.jl</a>, which similarly compiles Julia IR to MLIR, albeit using a tracing approach instead of the one outlined here.</p>
<p>In the beginning of this post I promised MLIR IR in the <code>affine</code> dialect, however we ended up with <code>scf</code> operations. Fear not, these can be <em>raised</em> to the <code>affine</code> dialect using <a href="https://polygeist.llvm.org/">Polygeist</a>.</p>
<pre class="language-sh"><code class="language-sh">polygeist-opt --allow-unregistered-dialect --raise-scf-to-affine --affine-cfg my_mlir.mlir</code></pre>
<p>which returns:</p>
<pre class="language-llvm"><code class="language-llvm">⋮
<span class="token keyword">affine</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token variable">%arg2</span> <span class="token punctuation">=</span> <span class="token number">1</span> <span class="token keyword">to</span> <span class="token variable">#map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token variable">%3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token variable">%4</span> <span class="token punctuation">=</span> <span class="token keyword">affine</span><span class="token punctuation">.</span><span class="token keyword">load</span> <span class="token variable">%arg1</span><span class="token punctuation">[</span><span class="token variable">%arg2</span> - <span class="token number">1</span><span class="token punctuation">]</span> : <span class="token keyword">memref</span><span class="token punctuation">&lt;</span>?<span class="token keyword">xf64</span><span class="token punctuation">,</span> <span class="token keyword">strided</span><span class="token punctuation">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token label">offset:</span> ?<span class="token punctuation">></span><span class="token punctuation">></span>
    <span class="token keyword">affine</span><span class="token punctuation">.</span><span class="token keyword">store</span> <span class="token variable">%4</span><span class="token punctuation">,</span> <span class="token variable">%arg0</span><span class="token punctuation">[</span><span class="token variable">%arg2</span> - <span class="token number">1</span><span class="token punctuation">]</span> : <span class="token keyword">memref</span><span class="token punctuation">&lt;</span>?<span class="token keyword">xf64</span><span class="token punctuation">,</span> <span class="token keyword">strided</span><span class="token punctuation">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token label">offset:</span> ?<span class="token punctuation">></span><span class="token punctuation">></span>
<span class="token punctuation">}</span>
⋮</code></pre>
<h2 id="where-to-go-from-here" tabindex="-1"><a class="header-anchor" href="#where-to-go-from-here">Where to Go From Here</a></h2>
<p>It's now possible to lower the generated MLIR to LLVM, which can then be compiled to machine code. Doing so doesn't really get us anything, though. Since we're not running any optimization passes, the performance we get is actually about the same as simply writing the loops yourself.<br>
What this whole exercise did give us, though, is the ability to run MLIR passes on the generated IR. <a href="https://mlir.llvm.org/docs/Dialects/Transform/">This webpage</a> contains an overview of transformations that are available in the upstream MLIR repository. Aditionally, there are other projects providing MLIR passes as well.<br>
The Polymer subproject of Polygeist also allows connecting <em>Pluto</em>, a more “traditional” polyhedral compilation tool, to MLIR.<br>
Other projects for optimizing MLIR include <a href="https://iree.dev/">IREE</a>, <a href="https://github.com/microsoft/Accera">Accera</a>, <a href="https://docs.polymagelabs.com/index.html">Polyblocks</a> (closed-source), and undoubtedly many more.<br>
Upstream MLIR does not contain a lot of automatic optimization passes, meaning that you'll have to develop your own heuristics or cost models to drive the tranformations. Some of the aforementioned tools do provide such automated optimizations, however, they typically constrain the type of IR they accept or have their own external dialects. For this reason it isn't trivial to integrate these tools yet, but it's definitely possible and I hope to explore this in the future.</p>
<p>This post started with the goal to generate MLIR in the <code>affine</code> dialect. It might be interesting to also consider the linear algebra dialect (<code>linalg</code>) since that dialect provides an einsum-inspired way to represent linear algebra operations.</p>
<p>The way loops are represented in Julia IR is not ideal. In fact, some more advanced einsum expressions fail to compile because the lowering to Julia IR is too aggressive and gets rid of some blocks in the control flow graph that are needed to generate the MLIR. The lack of high-level loops in Julia IR is a fundamental problem but more elegant workarounds might be possible. Currently this is definitely something that stands in the way of being a reliable tool instead of an initial proof-of-concept.</p>
<p>In the same vein, the code I wrote is <a href="https://github.com/jumerckx/compile_einsum/tree/blog">available on Github</a> but comes with no guarantees whatsoever. Things are flaky and might not work as expected but if you're on Linux, using <code>Julia 1.11.0-DEV.1141</code> or similar <label for="sn-no-julia-1.10" class="margin-toggle sidenote-number"></label></span><input type="checkbox" id="sn-no-julia-1.10" class="margin-toggle"/><span class="sidenote"><code>Julia 1.10</code> won't cut it because the code assumes the redesigned Array implementation.</span>, it should be possible to clone the repository and run the example on the <code>blog</code> branch.<br>
On Linux, an MLIR release should automatically be downloaded as an aritfact when instantiating the environment, on MacOS or Windows, you're on your own to provide a valid MLIR installation.</p>

</article>
	</body>
</html>
